#!/usr/bin/env node

/**
 *	TODO: 실제 채널 ls 기능 추가
 */

const program  = require('commander');
const chalk = require('chalk');

const fs = require('fs');

const settings = require('./settings');

const request = require('request');

let options = {
	host: '192.168.182.195',
	port: 48484,
	headers: {
		'Content-Type': 'application/json'
	}
}

program
	.option('-n, --number [optional]', 'Show channel items')
	.option('-c, --channel [optional]', 'Show channel items')
	.option('-w, --withoutch [optional]', 'Show without channel items')
	.parse(process.argv);

/**
 *	Options
 */
const number = program.number ? program.number : -1;
const wc = program.channel;
const woc = program.withoutch;

/**
 *	Validation
 */
if (false) { /* vali */ }

/**
 *	Verbose	
 */
console.log(chalk.green.bold('ls command'));
	
/**
 *	Read JSON file	
 */
let _todos = []
let _channels = [];
const SUBCHFILE = settings.SUBCHFILE;
const TODOFILE = settings.TODOFILE;

fs.readFile(TODOFILE, 'utf-8', (err, data) => {
	if (err) {
		console.error(chalk.red.bold(err));
		console.log(chalk.yellow.bold("--> New file will be created"));
	} else {
		_todos = JSON.parse(data);

		// channel 정보 가져오기from SUBCHFILE 
		if (fs.existsSync(SUBCHFILE)) {
			_channels = JSON.parse(fs.readFileSync(SUBCHFILE, 'utf8'));
			console.log("Subscribed channel list :", chalk.yellow(_channels.map((item)=>{return item.id}).join(",")))
		}

		// 구독하는 채널이 없다면
		if (_channels.length == 0) {
			showTodos(); return;
		}
		
		// channel이 하나 이상일 때
		for (i = 0; i < _channels.length; i++ ){
			/**
			 *	주의: i 를 이용하면 callback 에서 이미 i가 증가해버린 뒤여서 i에 대한 sync를 놓친다 
			 *	따라서 현재 i를 서버로 보냈다가
			 *	서버에서도 받은 i를 응답과 함께 넘겨주면 (tmpidx)
			 *	해당 i를 활용해서 처리한다
			 */
			request({
				url: 'http://192.168.182.195:48484/getch/' + _channels[i].id + "/" + i
			}, (error, response, body) => {
				if (error) {
					console.log(error);
					return;
				}
				
				const parsedBody = JSON.parse(body);
				const idx = parsedBody.tmpidx;
				if (parsedBody.status == "EMPTY") {
					console.log("Channel id : " + chalk.red.bold(_channels[idx].id + " has no items"));
					return;
				}
				else if (parsedBody.status == "NOCH") {
					console.log("Channel id : " + chalk.red.bold(_channels[idx].id + " not exist"));
					return;
				}
				let ts = parsedBody["content"];

				// 싱크가 맞지 않는 todo 추가 및 timestamp 기록
				let isSynced = false;
				for (t = 0 ; t < ts.length; t ++){
					if (!_channels[idx]["synced"].includes(ts[t].timestamp)){
						_channels[idx]["synced"].push(ts[t].timestamp);
						_todos.push({"todo": ts[t].todo, "secret": false, "ch": true});
						isSynced = true;
					}
				}
				
				if (!isSynced) return;

				fs.writeFileSync(SUBCHFILE, JSON.stringify(_channels), encoding="utf-8");
				fs.writeFileSync(TODOFILE, JSON.stringify(_todos), encoding="utf-8");
				console.log(chalk.blue.bold("New Todo item from Subscribed Channel [" + _channels[idx] + "]"));
			});
		}

		showTodos();
	}
});

/**
 *	show todo
 *	using global variable '_todos'
 */
function showTodos() {
	if (_todos.length == 0) {
		console.log(chalk.yellow.bold("[Empty]"));	
	}
	_todos.forEach((item, idx) => {
		if (number > 0 && number <= idx) return false;
		if ("ch" in item && !woc) console.log(chalk.cyan(idx + ". ", chalk.inverse(item.todo)));
		else	console.log(chalk.cyan(idx + ". "), chalk.yellow.bold(item.todo));	
	});
}
