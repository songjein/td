#!/usr/bin/env node

const fs = require('fs');
const axios = require('axios');
const chalk = require('chalk');
const program  = require('commander');
const inquirer = require('inquirer');
const showdown = require('showdown');

const converter = new showdown.Converter();

const utils = require('./utils');
const globals = require('./globals');

program
	.description('Write tech-blog article to https://tdls.dev using markdown file\n  the first line of the file should not be blank, it is considered as title of the article.')
	.option('-f, --file <file-path-required>', 'File path') 
	.option('-d, --deleteMode', 'Delete mode', false)
	.option('-i, --logId <log-id-required>', 'Id of the log which will be updated or deleted') 
	.parse(process.argv);

/**
 *	Options 
 */
const filePath = program.file; 
const logId = program.logId;
const deleteMode = program.deleteMode;

/**
 *	Validation	
 */

if (!deleteMode && !filePath && !logId) {
	console.error(chalk.red.bold('\nOptions required'));
	program.help();
	process.exit(1);
}

if (!deleteMode && !filePath) {
	console.error(chalk.red.bold('\nFile path required'));
	program.help();
	process.exit(1);
}

if (deleteMode && !logId) {
	console.error(chalk.red.bold('\nlogId required in deleteMode'));
	program.help();
	process.exit(1);
}

/**
 *	Verbose	
 */
console.log(chalk.green.bold('Log command'));

/**
 *	Do something
 */
const { KEY_FILE } = globals;
const logRoute= '/logs/';
const logDeleteRoute= '/logs/delete';

utils.notExistKeyFileExitProcess ();

const keyText = fs.readFileSync(KEY_FILE, 'utf-8');
const { firstKey, secondKey }= JSON.parse(keyText); 

const createOrUpdateLog = async () => {
	const md = fs.readFileSync(filePath, 'utf-8');

	// first line
	const maybeTitle = md.split('\n')[0].replace(/#/gi,'').trim();
	const titlePattern = /title\s*:\s*.*/;
	const matchedTitle = titlePattern.exec(maybeTitle); 

	let title = undefined;
	if (!matchedTitle) {
		console.log(
			chalk.red('You must write meta information for the title in the first line of markdown file')
		);
		console.log(chalk.yellow('ex) \'title: titleOfYourArticle\''));
		return;
	} else {
		title = matchedTitle[0].split(':')[1].trim();
		console.log('title:', chalk.yellow(title));	
	}

	// second line
	const maybeSourceList = md.split('\n')[1]; 
	const sourceListPattern = /source\s*:\s*\[.*\]/;
	const matchedSourceList = sourceListPattern.exec(maybeSourceList);

	let sourceList = undefined;
	if (matchedSourceList) {
		sourceList = JSON.parse(matchedSourceList[0].split(':')[1].trim());
		console.log('Source list detected:', sourceList);
	} else {
		console.log(chalk.red(chalk.yellow('Source list') + ' is not detected'));
		console.log(chalk.yellow(' ex) source: [log_id1, log_id2] (in second line of md file)'));	
	}
	
	// content of an article
	let htmlBody = undefined;	
	if (sourceList) {
		htmlBody = converter.makeHtml(md.split('\n').slice(2).join('\n'));
	} else {
		htmlBody = converter.makeHtml(md.split('\n').slice(1).join('\n'));
	}

	try {
		const payload = { firstKey, secondKey, title, sourceList, htmlBody, logId };
		const { data } = await axios.post(globals.API + logRoute, payload);
		utils.showResult(data);

	} catch (error) {
		console.error(error);
	}
}

const deleteLog = async () => {
	try {
		const payload = { firstKey, secondKey, logId };
		const questions = [
			{
				message: 'You really want to delete ' + chalk.yellow('https://tdls.dev/logs/' + chalk.red.bold(logId)),
				type: 'confirm',
				name: 'confirm',
				default: false,
			}	
		];
		const answers = await inquirer.prompt(questions);
		if (!answers.confirm) {
			console.log(chalk.yellow.bold(globals.NH_MSG));	
			return;
		}
		const { data } = await axios.post(globals.API + logDeleteRoute, payload);	
		utils.showResult(data);

	}	catch(error) {
		console.error(error);	
	}
}

if (!deleteMode) {
	createOrUpdateLog();
} else {
	deleteLog();
}
